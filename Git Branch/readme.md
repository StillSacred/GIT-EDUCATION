# Что такое Git
Git - распределённая система управления версиями. Проект был создан Линусом Торвальдсом для управления разработкой ядра Linux, первая версия выпущена 7 апреля 2005 года. На сегодняшний день его поддерживает Джунио Хамано.

Среди проектов, использующих Git — ядро Linux, Swift, Android, Drupal, Cairo, GNU Core Utilities, Mesa, Wine, Chromium, Compiz Fusion, FlightGear, jQuery, PHP, NASM, MediaWiki, DokuWiki, Qt, ряд дистрибутивов Linux.

# Подготовка репозитория
Подготовить локальный репозиторий можно двумя способами: создать репозиторий с нуля с последующим
переносом изменений в удаленный репозиторий и сделать клон удаленного репозитория.
Первый способ создание локального репозитория с нуля командойgit init.
Создадим проект на локальной машине с таким именем:
mkdir your_project
перейдем в этот каталог:
cd your_project
Выполним команду git init которая инициирует локальный репозиторий:
git init
Дальше можно добавлять файлы в локальный репозиторий.

# Создание "сохранений"

Итак, у вас имеется настоящий Git-репозиторий и рабочая копия файлов для некоторого проекта. Вам нужно делать некоторые изменения и фиксировать «снимки» состояния (snapshots) этих изменений в вашем репозитории каждый раз, когда проект достигает состояния, которое вам хотелось бы сохранить.

Запомните, каждый файл в вашем рабочем каталоге может находиться в одном из двух состояний: под версионным контролем (отслеживаемые) и нет (неотслеживаемые). Отслеживаемые файлы — это те файлы, которые были в последнем снимке состояния проекта; они могут быть неизменёнными, изменёнными или подготовленными к коммиту. Если кратко, то отслеживаемые файлы — это те файлы, о которых знает Git.

Неотслеживаемые файлы — это всё остальное, любые файлы в вашем рабочем каталоге, которые не входили в ваш последний снимок состояния и не подготовлены к коммиту. Когда вы впервые клонируете репозиторий, все файлы будут отслеживаемыми и неизменёнными, потому что Git только что их извлек и вы ничего пока не редактировали.

Как только вы отредактируете файлы, Git будет рассматривать их как изменённые, так как вы изменили их с момента последнего коммита. Вы индексируете эти изменения, затем фиксируете все проиндексированные изменения, а затем цикл повторяется.

![lifecycle](lifecycle.jpg)

# Переключение между "сохранениями"

Для переключения на нужный коммит используется действие checkout.

После переключения, все файлы в проекте станут такими, какими они были в данном коммите.

git checkout commit

Где commit - это хеш (обозначение, имя) коммита, причем можно указывать не весь хеш, а несколько начальных символов хеша.

Вопрос: А как вернуться в самое свежее состояние?

Ответ. Команда:

git checkout

без дополнительных параметров вернет вас в head ревизию.

# Журнал изменений

Git log

Показывает журналы коммитов.

Перечислите коммиты, достижимые по parentссылкам из заданных коммитов, но исключите коммиты, достижимые из тех, которые указаны со знаком ^ перед ними. Вывод по умолчанию выдается в обратном хронологическом порядке.

Вы можете думать об этом как об операции набора. Коммиты, достижимые из любых коммитов, указанных в командной строке, образуют набор, а затем из этого набора вычитаются коммиты, достижимые из любого из коммитов, указанных со знаком ^ впереди. Остальные коммиты — это то, что выходит в выводе команды. Различные другие параметры и параметры пути могут быть использованы для дальнейшего ограничения результата.

Таким образом, следующая команда:

$ git log foo bar ^baz
означает «перечислите все коммиты, которые доступны из foo или bar , но не из baz ».

Специальное обозначение " <commit1> .. <commit2> " можно использовать как сокращение для "^ <commit1> <commit2> ". Например, любое из следующего может использоваться взаимозаменяемо:

$ git источник журнала.. ГОЛОВА
$ git log HEAD ^ происхождение
Другая специальная нотация — « <commit1> …​ < commit2> », которая полезна для слияний. Результирующий набор коммитов представляет собой симметричную разницу между двумя операндами. Следующие две команды эквивалентны:

$ git log AB --not $(git merge-base --all AB)
$ git журнал A...B
Команда принимает параметры, применимые к команде git-rev-list[1] для управления тем, что и как отображается, и параметры, применимые к команде git-diff[1] , для управления тем, как отображаются изменения, вносимые каждой фиксацией.

# Ветки в Git

Ветка в Git это подвижный указатель на один из коммитов. Обычно ветка указывает на последний коммит в цепочке коммитов. Ветка берет свое начало от какого-то одного коммита.

Сделать новую ветку и переключиться на нее можно выполнив команды

git pull
git checkout –b <имя новой ветки>

Просто сделать ветку, не переключаясь на нее можно командой

git branch <имя ветки>

переключиться на ветку

git checkout <имя ветки>

Важно понимать, что ветка берет свое начало не от ветки, а от последнего коммита который находиться в той ветке, в которой вы находились.

# Слияние веток и разрешение конфликтов

Ветка обычно заканчивается специальным merge коммитом, который говорит, что ветку нужно объединить с какой-то другой веткой. В merge коммите содержатся две ссылки на два коммита которые объединяются в одну ветку.

Существует другая ситуация при объединении веток, в которой merge может произойти без merge commit. Дело в том, что если в одной из веток не произошло никаких изменений, то необходимость в merge commit с двумя предками отпадает. В таком случае, при слиянии веток, Git просто сделает пометку о том, что дальше будут идти коммиты той ветки с которой эта ветка была объединена. Такая схема merge называется слияние-перемотка (fast-forward merge).

Во всех этих случаях, после того, как ветка объединяется с другой веткой, все коммиты сделанные в ней, попадают в ветку с которой она была объединена. Так же важно понимать, что merge это не двунаправленная операция. Если смержить ветку задачи в мастер ветку, то в мастер ветке появится код, который находился в ветке задачи, а в ветке задачи не появиться новый код из мастер ветки. Если нужно что бы это произошло, нужно смержить мастер ветку в ветку задачи.
Что бы смержить одну ветку в другую нужно вначале переключиться на ту ветку, в которую вы хотите смержить

git checkout <имя ветки>

Потом получить последние изменения сделанные в этой ветке выполнив

git pull

Затем выполнить команду

git merge <имя ветки>

Так выглядит работа с ветками в общих чертах.

Обратите внимание на то, что перед тем как заводить новую ветку нужно выполнить git pull. Делается это по нескольким причинам.
Другой программист мог изменить код, в том числе внести такие изменения, которые повлияют на решение задачи, для которой вы заводите новую ветку. Эти изменения могут вам пригодиться при решении своей задачи.
Из-за этих изменений вы можете получить конфликт при мерже.
Больше шанс что у вас получится merge commit. Это не так плохо, как два предыдущих пункта. Но если можно избежать лишнего коммита, то почему бы этого не сделать?

# Удаление веток